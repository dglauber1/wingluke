'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _Cell = require('./Cell');

var _Cell2 = _interopRequireDefault(_Cell);

var _classnames = require('classnames');

var _classnames2 = _interopRequireDefault(_classnames);

var _Board = require('./Board.css');

var _Board2 = _interopRequireDefault(_Board);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

// Adapted (ok, mostly copied) from https://github.com/saninmersion/react-minesweeper

var Board = function (_React$Component) {
    _inherits(Board, _React$Component);

    function Board() {
        var _ref;

        var _temp, _this, _ret;

        _classCallCheck(this, Board);

        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
        }

        return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_ref = Board.__proto__ || Object.getPrototypeOf(Board)).call.apply(_ref, [this].concat(args))), _this), _this.state = {
            boardData: _this.initBoardData(_this.props.height, _this.props.width, _this.props.mines),
            gameWon: false,
            gameLost: false,
            mineCount: _this.props.mines
        }, _temp), _possibleConstructorReturn(_this, _ret);
    }

    _createClass(Board, [{
        key: 'getMines',


        /* Helper Functions */

        // get mines
        value: function getMines(data) {
            var mineArray = [];

            data.map(function (datarow) {
                datarow.map(function (dataitem) {
                    if (dataitem.isMine) {
                        mineArray.push(dataitem);
                    }
                });
            });

            return mineArray;
        }

        // get Flags

    }, {
        key: 'getFlags',
        value: function getFlags(data) {
            var mineArray = [];

            data.map(function (datarow) {
                datarow.map(function (dataitem) {
                    if (dataitem.isFlagged) {
                        mineArray.push(dataitem);
                    }
                });
            });

            return mineArray;
        }

        // get Hidden cells

    }, {
        key: 'getHidden',
        value: function getHidden(data) {
            var mineArray = [];

            data.map(function (datarow) {
                datarow.map(function (dataitem) {
                    if (!dataitem.isRevealed) {
                        mineArray.push(dataitem);
                    }
                });
            });

            return mineArray;
        }

        // get random number given a dimension

    }, {
        key: 'getRandomNumber',
        value: function getRandomNumber(dimension) {
            // return Math.floor(Math.random() * dimension);
            return Math.floor(Math.random() * 1000 + 1) % dimension;
        }

        // Gets initial board data

    }, {
        key: 'initBoardData',
        value: function initBoardData(height, width, mines) {
            var data = [];

            for (var i = 0; i < height; i++) {
                data.push([]);
                for (var j = 0; j < width; j++) {
                    data[i][j] = {
                        x: i,
                        y: j,
                        isMine: false,
                        neighbour: 0,
                        isRevealed: false,
                        isEmpty: false,
                        isFlagged: false
                    };
                }
            }
            data = this.plantMines(data, height, width, mines);
            data = this.getNeighbours(data, height, width);
            console.log(data);
            return data;
        }

        // plant mines on the board

    }, {
        key: 'plantMines',
        value: function plantMines(data, height, width, mines) {
            var randomx = void 0,
                randomy = void 0,
                minesPlanted = 0;

            while (minesPlanted < mines) {
                randomx = this.getRandomNumber(width);
                randomy = this.getRandomNumber(height);
                if (!data[randomx][randomy].isMine) {
                    data[randomx][randomy].isMine = true;
                    minesPlanted++;
                }
            }

            return data;
        }

        // get number of neighbouring mines for each board cell

    }, {
        key: 'getNeighbours',
        value: function getNeighbours(data, height, width) {
            var _this2 = this;

            var updatedData = data,
                index = 0;

            for (var i = 0; i < height; i++) {
                for (var j = 0; j < width; j++) {
                    if (data[i][j].isMine !== true) {
                        (function () {
                            var mine = 0;
                            var area = _this2.traverseBoard(data[i][j].x, data[i][j].y, data);
                            area.map(function (value) {
                                if (value.isMine) {
                                    mine++;
                                }
                            });
                            if (mine === 0) {
                                updatedData[i][j].isEmpty = true;
                            }
                            updatedData[i][j].neighbour = mine;
                        })();
                    }
                }
            }

            return updatedData;
        }
    }, {
        key: 'traverseBoard',


        // looks for neighbouring cells and returns them
        value: function traverseBoard(x, y, data) {
            var el = [];

            //up
            if (x > 0) {
                el.push(data[x - 1][y]);
            }

            //down
            if (x < this.props.height - 1) {
                el.push(data[x + 1][y]);
            }

            //left
            if (y > 0) {
                el.push(data[x][y - 1]);
            }

            //right
            if (y < this.props.width - 1) {
                el.push(data[x][y + 1]);
            }

            // top left
            if (x > 0 && y > 0) {
                el.push(data[x - 1][y - 1]);
            }

            // top right
            if (x > 0 && y < this.props.width - 1) {
                el.push(data[x - 1][y + 1]);
            }

            // bottom right
            if (x < this.props.height - 1 && y < this.props.width - 1) {
                el.push(data[x + 1][y + 1]);
            }

            // bottom left
            if (x < this.props.height - 1 && y > 0) {
                el.push(data[x + 1][y - 1]);
            }

            return el;
        }

        // reveals the whole board

    }, {
        key: 'revealBoard',
        value: function revealBoard() {
            var updatedData = this.state.boardData;
            updatedData.map(function (datarow) {
                datarow.map(function (dataitem) {
                    dataitem.isRevealed = true;
                });
            });
            this.setState({
                boardData: updatedData
            });
        }

        /* reveal logic for empty cell */

    }, {
        key: 'revealEmpty',
        value: function revealEmpty(x, y, data) {
            var _this3 = this;

            var area = this.traverseBoard(x, y, data);
            area.map(function (value) {
                if (!value.isRevealed && (value.isEmpty || !value.isMine)) {
                    data[value.x][value.y].isRevealed = true;
                    if (value.isEmpty) {
                        _this3.revealEmpty(value.x, value.y, data);
                    }
                }
            });
            return data;
        }

        // Handle User Events

    }, {
        key: 'handleCellClick',
        value: function handleCellClick(x, y) {
            var win = false;
            var lost = false;

            // check if revealed. return if true.
            if (this.state.boardData[x][y].isRevealed) return null;

            // check if mine. game over if true
            if (this.state.boardData[x][y].isMine) {
                lost = true;
                this.revealBoard();
            }

            var updatedData = this.state.boardData;
            updatedData[x][y].isFlagged = false;
            updatedData[x][y].isRevealed = true;

            if (updatedData[x][y].isEmpty) {
                updatedData = this.revealEmpty(x, y, updatedData);
            }

            if (this.getHidden(updatedData).length === this.props.mines) {
                win = true;
                this.revealBoard();
            }

            this.setState({
                boardData: updatedData,
                mineCount: this.props.mines - this.getFlags(updatedData).length,
                gameWon: win,
                gameLost: lost
            });
        }
    }, {
        key: 'handleRestartClick',
        value: function handleRestartClick() {
            this.setState({
                boardData: this.initBoardData(this.props.height, this.props.width, this.props.mines),
                mineCount: this.props.mines,
                gameWon: false,
                gameLost: false
            });
        }
    }, {
        key: '_handleContextMenu',
        value: function _handleContextMenu(e, x, y) {
            e.preventDefault();
            var updatedData = this.state.boardData;
            var mines = this.state.mineCount;
            var win = false;

            // check if already revealed
            if (updatedData[x][y].isRevealed) return;

            if (updatedData[x][y].isFlagged) {
                updatedData[x][y].isFlagged = false;
                mines++;
            } else {
                updatedData[x][y].isFlagged = true;
                mines--;
            }

            if (mines === 0) {
                var mineArray = this.getMines(updatedData);
                var FlagArray = this.getFlags(updatedData);
                win = JSON.stringify(mineArray) === JSON.stringify(FlagArray);
                if (win) {
                    this.revealBoard();
                }
            }

            this.setState({
                boardData: updatedData,
                mineCount: mines,
                gameWon: win
            });
        }
    }, {
        key: 'renderBoard',
        value: function renderBoard(data) {
            var _this4 = this;

            return data.map(function (datarow) {
                return datarow.map(function (dataitem) {
                    return _react2.default.createElement(_Cell2.default, {
                        onClick: function onClick() {
                            return _this4.handleCellClick(dataitem.x, dataitem.y);
                        },
                        cMenu: function cMenu(e) {
                            return _this4._handleContextMenu(e, dataitem.x, dataitem.y);
                        },
                        value: dataitem,
                        key: dataitem.x * datarow.length + dataitem.y,
                        clear: datarow[datarow.length - 1] === dataitem
                    });
                });
            });
        }
        // Component methods

    }, {
        key: 'componentWillReceiveProps',
        value: function componentWillReceiveProps(nextProps) {
            if (JSON.stringify(this.props) !== JSON.stringify(nextProps)) {
                this.setState({
                    boardData: this.initBoardData(nextProps.height, nextProps.width, nextProps.mines),
                    gameWon: false,
                    gameLost: false,
                    mineCount: nextProps.mines
                });
            }
        }
    }, {
        key: 'render',
        value: function render() {
            var _cx,
                _this5 = this;

            var boardClassName = (0, _classnames2.default)(_Board2.default.board, (_cx = {}, _defineProperty(_cx, _Board2.default.boardByEight, this.props.width == 8), _defineProperty(_cx, _Board2.default.boardByNine, this.props.width == 9), _defineProperty(_cx, _Board2.default.boardByTen, this.props.width == 10), _cx));

            return _react2.default.createElement(
                'div',
                { className: _Board2.default.game },
                _react2.default.createElement(
                    'div',
                    { className: _Board2.default.gameInfoContainer },
                    _react2.default.createElement(
                        'button',
                        { className: _Board2.default.restartButton, onClick: function onClick() {
                                return _this5.handleRestartClick();
                            } },
                        'Restart'
                    ),
                    _react2.default.createElement(
                        'span',
                        { className: _Board2.default.gameInfo },
                        'Mines: ',
                        this.state.mineCount
                    ),
                    _react2.default.createElement('br', null),
                    _react2.default.createElement(
                        'span',
                        { className: _Board2.default.gameInfo },
                        this.state.gameWon ? "You Win" : this.state.gameLost ? "You lost!" : ""
                    )
                ),
                _react2.default.createElement(
                    'div',
                    { className: boardClassName },
                    this.renderBoard(this.state.boardData)
                )
            );
        }
    }]);

    return Board;
}(_react2.default.Component);

exports.default = Board;